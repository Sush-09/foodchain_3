// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../ownership/Ownable.sol";
import "../access/FarmerRole.sol";
import "../access/ManufacturerRole.sol";
import "../access/DistributorRole.sol";
import "../access/RetailerRole.sol";
import "../access/ConsumerRole.sol";

// Define a contract 'Supplychain'
contract SupplyChain is
    Ownable,
    FarmerRole,
    ManufacturerRole,
    DistributorRole,
    RetailerRole,
    ConsumerRole
{
    // Define 'owner'
    address owner;

    // Define a variable called 'productCode' for Universal Product Code (productCode)
    uint256 productCode;

    // Define a variable called 'stockUnit' for Stock Keeping Unit (stockUnit)
    uint256 stockUnit;

    // Define a public mapping 'items' that maps the productCode to an Item.
    mapping(uint256 => Item) items;

    // Define a public mapping 'itemsHistory' that maps the productCode to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping(uint256 => Txblocks) itemsHistory;

    // Define enum 'State' with the following values:
    enum State {
        ProduceByFarmer, // 0
        ForSaleByFarmer, // 1
        PurchasedByManufacturer, // 2
        ShippedByFarmer, // 3
        ReceivedByManufacturer, // 4
        ProcessedByManufacturer, // 5
        PackagedByManufacturer, // 6
        ForSaleByManufacturer, // 7
        PurchasedByDistributor,//8
        ShippedByManufacturer,//9
        ReceivedByDistributor,//10
        ForSaleByDistributor, // 11
        PurchasedByRetailer, // 12
        ShippedByDistributor, // 13
        ReceivedByRetailer, // 14
        ForSaleByRetailer, // 15
        PurchasedByConsumer // 16
    }

    State constant defaultState = State.ProduceByFarmer;

    // Define a struct 'Item' with the following fields:
    struct Item {
        uint256 stockUnit; // Stock Keeping Unit (stockUnit)
        uint256 productCode; // Universal Product Code (productCode), generated by the Farmer, goes on the package, can be verified by the Consumer
        address ownerID; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address originFarmerID; // Metamask-Ethereum address of the Farmer // ADDED PAYABLE
        string originFarmName; // Farmer Name
        string originFarmInformation; // Farmer Information
        string originFarmLatitude; // Farm Latitude
        string originFarmLongitude; // Farm Longitude
        uint256 productID; // Product ID potentially a combination of productCode + stockUnit
        string productNotes; // Product Notes
        uint256 productDate; // Product Date NOTE: MIGHT NEED TO CHANGE type
        uint256 productPrice; // Product Price
        uint256 productSliced; // Parent cheese
        State itemState; // Product State as represented in the enum above
        address manufacturerID;
        address distributorID; // Metamask-Ethereum address of the Distributor
        address retailerID; // Metamask-Ethereum address of the Retailer
        address consumerID; // Metamask-Ethereum address of the Consumer // ADDED payable
    }

    // Block number stuct
    struct Txblocks {
        uint256 FTM; // blockfarmerToDistributor
        uint256 MTD;
        uint256 DTR; // blockDistributorToRetailer
        uint256 RTC; // blockRetailerToConsumer
    }

    event ProduceByFarmer(uint256 productCode); //1
    event ForSaleByFarmer(uint256 productCode); //2
    event PurchasedByManufacturer(uint256 productCode);//3
    event ShippedByFarmer(uint256 productCode); //4
    event ReceivedByManufacturer(uint256 productCode); //5
    event ProcessedByManufacturer(uint256 productCode); //6
    event PackagedByManufacturer(uint256 productCode); //7
    event ForSaleByManufacturer(uint256 productCode); //8
    event PurchasedByDistributor(uint256 productCode); //9
    event ShippedByManufacturer(uint256 productCode); //10
    event ReceivedByDistributor(uint256 productCode); //11
    event ForSaleByDistributor(uint256 productCode); //12
    event PurchasedByRetailer(uint256 productCode); //13
    event ShippedByDistributor(uint256 productCode); //14
    event ReceivedByRetailer(uint256 productCode); //15
    event ForSaleByRetailer(uint256 productCode); //16
    event PurchasedByConsumer(uint256 productCode); //17

    
    // Define a modifer that checks to see if _msgSender() == owner of the contract
    modifier only_Owner() {
        require(_msgSender() == owner);
        _;
    }

    // Define a modifer that verifies the Caller
    modifier verifyCaller(address _address) {
        require(_msgSender() == _address);
        _;
    }

    // Define a modifier that checks if the paid amount is sufficient to cover the price
    modifier paidEnough(uint256 _price) {
        require(msg.value >= _price);
        _;
    }

    // Define a modifier that checks the price and refunds the remaining balance
    modifier checkValue(uint256 _productCode, address payable addressToFund) {
        uint256 _price = items[_productCode].productPrice;
        uint256 amountToReturn = msg.value - _price;
        addressToFund.transfer(amountToReturn);
        _;
    }

    //Item State Modifiers
    modifier producedByFarmer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ProduceByFarmer);
        _;
    }

    modifier forSaleByFarmer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ForSaleByFarmer);
        _;
    }

    modifier purchasedByManufacturer(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByManufacturer);
        _;
    }

    modifier shippedByFarmer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ShippedByFarmer);
        _;
    }

    modifier receivedByManufacturer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ReceivedByManufacturer);
        _;
    }

    modifier processedByManufacturer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ProcessedByManufacturer);
        _;
    }

    modifier packagedByManufacturer(uint256 _productCode) {
        require(items[_productCode].itemState == State.PackagedByManufacturer);
        _;
    }

    modifier forSaleByManufacturer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ForSaleByManufacturer);
        _;
    }

    modifier purchasedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByDistributor);
        _;
    }

    modifier shippedByManufacturer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ShippedByManufacturer);
        _;
    }

    modifier receivedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ReceivedByDistributor);
        _;
    }

    modifier forSaleByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ForSaleByDistributor);
        _;
    }

    modifier shippedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ShippedByDistributor);
        _;
    }

    modifier purchasedByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByRetailer);
        _;
    }

    modifier receivedByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ReceivedByRetailer);
        _;
    }

    modifier forSaleByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ForSaleByRetailer);
        _;
    }

    modifier purchasedByConsumer(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByConsumer);
        _;
    }

    // constructor setup owner stockUnit productCode
    constructor() public payable {
        owner = _msgSender();
        stockUnit = 1;
        productCode = 1;
    }

    // Define a function 'kill'
    function kill() public {
        if (_msgSender() == owner) {
            address payable ownerAddressPayable = _make_payable(owner);
            selfdestruct(ownerAddressPayable);
        }
    }

    // allows you to convert an address into a payable address
    function _make_payable(address x) internal pure returns (address payable) {
        return payable(address(uint160(x)));
    }

    /*
 1st step in supplychain
 Allows farmer to create cheese
*/
    function produceItemByFarmer(
        uint256 _productCode,
        string memory _originFarmName,
        string memory _originFarmInformation,
        string memory _originFarmLatitude,
        string memory _originFarmLongitude,
        string memory _productNotes,
        uint256 _price
    )
        public
        onlyFarmer // check address belongs to farmerRole
    {
        address manufacturerID;
        address distributorID; // Empty distributorID address
        address retailerID; // Empty retailerID address
        address consumerID; // Empty consumerID address
        Item memory newProduce; // Create a new struct Item in memory
        newProduce.stockUnit = stockUnit; // Stock Keeping Unit (stockUnit)
        newProduce.productCode = _productCode; // Universal Product Code (productCode), generated by the Farmer, goes on the package, can be verified by the Consumer
        newProduce.ownerID = _msgSender(); // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        newProduce.originFarmerID = _msgSender(); // Metamask-Ethereum address of the Farmer
        newProduce.originFarmName = _originFarmName; // Farmer Name
        newProduce.originFarmInformation = _originFarmInformation; // Farmer Information
        newProduce.originFarmLatitude = _originFarmLatitude; // Farm Latitude
        newProduce.originFarmLongitude = _originFarmLongitude; // Farm Longitude
        newProduce.productID = _productCode + stockUnit; // Product ID
        newProduce.productNotes = _productNotes; // Product Notes
        newProduce.productPrice = _price; // Product Price
        newProduce.productDate = block.timestamp;
        newProduce.productSliced = 0;
        newProduce.itemState = defaultState; // Product State as represented in the enum above
        newProduce.manufacturerID = manufacturerID;
        newProduce.distributorID = distributorID; // Metamask-Ethereum address of the Distributor
        newProduce.retailerID = retailerID; // Metamask-Ethereum address of the Retailer
        newProduce.consumerID = consumerID; // Metamask-Ethereum address of the Consumer // ADDED payable
        items[_productCode] = newProduce; // Add newProduce to items struct by productCode
        uint256 placeholder; // Block number place holder
        Txblocks memory txBlock; // create new txBlock struct
        txBlock.FTM = placeholder; // assign placeholder values
        txBlock.MTD = placeholder;
        txBlock.DTR = placeholder;
        txBlock.RTC = placeholder;
        itemsHistory[_productCode] = txBlock; 
        // Increment stockUnit
        stockUnit = stockUnit + 1;

        // Emit the appropriate event
        emit ProduceByFarmer(_productCode);
    }

    /*
2nd step in supplychain
Allows farmer to sell cheese
*/
    function sellItemByFarmer(uint256 _productCode, uint256 _price)
        public
        onlyFarmer // check _msgSender() belongs to farmerRole
        producedByFarmer(_productCode) // check items state has been produced
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.ForSaleByFarmer;
        items[_productCode].productPrice = _price;
        emit ForSaleByFarmer(_productCode);
    }

     /*
3rd step in supplychain
Allows distributor to purchase cheese
*/
    function purchaseItemByManufacturer(uint256 _productCode)
        public
        payable
        onlyManufacturer // check _msgSender() belongs to distributorRole
        forSaleByFarmer(_productCode) // check items state is for ForSaleByFarmer
        paidEnough(items[_productCode].productPrice) // check if distributor sent enough Ether for cheese
        checkValue(_productCode, payable(_msgSender())) // check if overpayed return remaing funds back to _msgSender()
    {
        address payable ownerAddressPayable = _make_payable(
            items[_productCode].originFarmerID
        ); // make originFarmID payable
        ownerAddressPayable.transfer(items[_productCode].productPrice); // transfer funds from distributor to farmer
        items[_productCode].ownerID = _msgSender(); // update owner
        items[_productCode].manufacturerID = _msgSender(); // update distributor
        items[_productCode].itemState = State.PurchasedByManufacturer; // update state
        itemsHistory[_productCode].FTM = block.number; // add block number
        emit PurchasedByManufacturer(_productCode);
    }

 /*
  4th step in supplychain
  Allows farmer to ship cheese purchased by distributor
  */
    function shippedItemByFarmer(uint256 _productCode)
        public
        payable
        onlyFarmer // check _msgSender() belongs to FarmerRole
        purchasedByManufacturer(_productCode)
        verifyCaller(items[_productCode].originFarmerID) // check _msgSender() is originFarmID
    {
        items[_productCode].itemState = State.ShippedByFarmer; // update state
        emit ShippedByFarmer(_productCode);
    }

     /*
  5th step in supplychain
  Allows Mnaaufacturerto receive cheese
  */
    function receivedItemByManufacturer(uint256 _productCode)
        public
        onlyManufacturer // check _msgSender() belongs to DistributorRole
        shippedByFarmer(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.ReceivedByManufacturer; // update state
        emit ReceivedByManufacturer(_productCode);
    }

     /*
  6th step in supplychain
  Allows distributor to process cheese
  */
    function processedItemByManufacturer(uint256 _productCode, uint256 slices)
        public
        onlyManufacturer // check _msgSender() belongs to DistributorRole
        receivedByManufacturer(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.ProcessedByManufacturer; // update state
        items[_productCode].productSliced = slices; // add slice amount
        emit ProcessedByManufacturer(_productCode);
    }

     /*
  7th step in supplychain
  Allows Manufacturer to package cheese
  */
    function packageItemByManufacturer(uint256 _productCode)
        public
        onlyManufacturer// check _msgSender() belongs to DistributorRole
        processedByManufacturer(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.PackagedByManufacturer;
        emit PackagedByManufacturer(_productCode);
    }

     /*
  8th step in supplychain
  Allows Manufacturer to sell cheese
  */
    function sellItemByManufacturer(uint256 _productCode, uint256 _price)
        public
        onlyManufacturer // check _msgSender() belongs to DistributorRole
        packagedByManufacturer(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.ForSaleByManufacturer;
        items[_productCode].productPrice = _price;
        emit ForSaleByManufacturer(productCode);
    }

    /*
9th step in supplychain
Allows distributor to purchase cheese
*/
    function purchaseItemByDistributor(uint256 _productCode)
        public
        payable
        onlyDistributor // check _msgSender() belongs to distributorRole
        forSaleByManufacturer(_productCode) // check items state is for ForSaleByFarmer
        paidEnough(items[_productCode].productPrice) // check if distributor sent enough Ether for cheese
        checkValue(_productCode, payable(_msgSender())) // check if overpayed return remaing funds back to _msgSender()
    {
        address payable ownerAddressPayable = _make_payable(
            items[_productCode].originFarmerID
        ); // make originFarmID payable
        ownerAddressPayable.transfer(items[_productCode].productPrice); // transfer funds from distributor to farmer
        items[_productCode].ownerID = _msgSender(); // update owner
        items[_productCode].distributorID = _msgSender(); // update distributor
        items[_productCode].itemState = State.PurchasedByDistributor; // update state
        itemsHistory[_productCode].MTD = block.number; // add block number
        emit PurchasedByDistributor(_productCode);
    }

 /*
  10th step in supplychain
  Allows Distributor to
  */
    function shippedItemByManufacturer(uint256 _productCode)
        public
        onlyManufacturer // check _msgSender() belongs to DistributorRole
        purchasedByDistributor(_productCode)
        verifyCaller(items[_productCode].distributorID) // check _msgSender() is distributorID
    {
        items[_productCode].itemState = State.ShippedByManufacturer;
        emit ShippedByManufacturer(_productCode);
    }

   

    /*
  11th step in supplychain
  Allows distributor to receive cheese
  */
    function receivedItemByDistributor(uint256 _productCode)
        public
        onlyDistributor // check _msgSender() belongs to DistributorRole
        shippedByManufacturer(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.ReceivedByDistributor; // update state
        emit ReceivedByDistributor(_productCode);
    }

    

   

    /*
  12th step in supplychain
  Allows distributor to sell cheese
  */
    function sellItemByDistributor(uint256 _productCode, uint256 _price)
        public
        onlyDistributor // check _msgSender() belongs to DistributorRole
        receivedByDistributor(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.ForSaleByDistributor;
        items[_productCode].productPrice = _price;
        emit ForSaleByDistributor(productCode);
    }

    /*
  13th step in supplychain
  Allows retailer to purchase cheese
  */
    function purchaseItemByRetailer(uint256 _productCode)
        public
        payable
        onlyRetailer // check _msgSender() belongs to RetailerRole
        forSaleByDistributor(_productCode)
        paidEnough(items[_productCode].productPrice)
        checkValue(_productCode, payable(_msgSender()))
    {
        address payable ownerAddressPayable = _make_payable(
            items[_productCode].distributorID
        );
        ownerAddressPayable.transfer(items[_productCode].productPrice);
        items[_productCode].ownerID = _msgSender();
        items[_productCode].retailerID = _msgSender();
        items[_productCode].itemState = State.PurchasedByRetailer;
        itemsHistory[_productCode].DTR = block.number;
        emit PurchasedByRetailer(_productCode);
    }

    /*
  14th step in supplychain
  Allows Distributor to
  */
    function shippedItemByDistributor(uint256 _productCode)
        public
        onlyDistributor // check _msgSender() belongs to DistributorRole
        purchasedByRetailer(_productCode)
        verifyCaller(items[_productCode].distributorID) // check _msgSender() is distributorID
    {
        items[_productCode].itemState = State.ShippedByDistributor;
        emit ShippedByDistributor(_productCode);
    }

    /*
  11th step in supplychain
  */
    function receivedItemByRetailer(uint256 _productCode)
        public
        onlyRetailer // check _msgSender() belongs to RetailerRole
        shippedByDistributor(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is ownerID
    {
        items[_productCode].itemState = State.ReceivedByRetailer;
        emit ReceivedByRetailer(_productCode);
    }

    /*
  12th step in supplychain
  */
    function sellItemByRetailer(uint256 _productCode, uint256 _price)
        public
        onlyRetailer // check _msgSender() belongs to RetailerRole
        receivedByRetailer(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is ownerID
    {
        items[_productCode].itemState = State.ForSaleByRetailer;
        items[_productCode].productPrice = _price;
        emit ForSaleByRetailer(_productCode);
    }

    /*
  13th step in supplychain
  */
    function purchaseItemByConsumer(uint256 _productCode)
        public
        payable
        onlyConsumer // check _msgSender() belongs to ConsumerRole
        forSaleByRetailer(_productCode)
        paidEnough(items[_productCode].productPrice)
        checkValue(_productCode, payable(_msgSender()))
    {
        items[_productCode].consumerID = _msgSender();
        address payable ownerAddressPayable = _make_payable(
            items[_productCode].retailerID
        );
        ownerAddressPayable.transfer(items[_productCode].productPrice);
        items[_productCode].ownerID = _msgSender();
        items[_productCode].consumerID = _msgSender();
        items[_productCode].itemState = State.PurchasedByConsumer;
        itemsHistory[_productCode].RTC = block.number;
        emit PurchasedByConsumer(_productCode);
    }

    // Define a function 'fetchItemBufferOne' that fetches the data
    function fetchItemBufferOne(uint256 _productCode)
        public
        view
        returns (
            uint256 itemstockUnit,
            uint256 itemproductCode,
            address ownerID,
            address originFarmerID,
            string memory originFarmName,
            string memory originFarmInformation,
            string memory originFarmLatitude,
            string memory originFarmLongitude,
            uint256 productDate,
            uint256 productSliced
        )
    {
        // Assign values to the 8 parameters
        Item memory item = items[_productCode];

        return (
            item.stockUnit,
            item.productCode,
            item.ownerID,
            item.originFarmerID,
            item.originFarmName,
            item.originFarmInformation,
            item.originFarmLatitude,
            item.originFarmLongitude,
            item.productDate,
            item.productSliced
        );
    }

    // Define a function 'fetchItemBufferTwo' that fetches the data
    function fetchItemBufferTwo(uint256 _productCode)
        public
        view
        returns (
            uint256 itemstockUnit,
            uint256 itemproductCode,
            uint256 productID,
            string memory productNotes,
            uint256 productPrice,
            uint256 productDate,
            State itemState,
            address manufacturerID,
            address distributorID,
            address retailerID,
            address consumerID
        )
    {
        // Assign values to the 9 parameters
        Item memory item = items[_productCode];

        return (
            item.stockUnit,
            item.productCode,
            item.productID,
            item.productNotes,
            item.productPrice,
            item.productDate,
            item.itemState,
            item.manufacturerID,
            item.distributorID,
            item.retailerID,
            item.consumerID
        );
    }

    // Define a function 'fetchItemHistory' that fetaches the data
    function fetchitemHistory(uint256 _productCode)
        public
        view
        returns (
            uint256 blockfarmerToManufacturer,
            uint256 blockManufacturerToDistributer,
            uint256 blockDistributorToRetailer,
            uint256 blockRetailerToConsumer
        )
    {
        // Assign value to the parameters
        Txblocks memory txblock = itemsHistory[_productCode];
        return (txblock.FTM,txblock.MTD, txblock.DTR, txblock.RTC);
    }
}